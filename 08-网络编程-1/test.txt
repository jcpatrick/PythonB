pdb调试：
命令-------------简写命令--------------作用
break------------b---------------------设置断点
continue---------c----------------------继续执行程序
list-------------l---------------------查看当前代码代码
step-------------s---------------------进入函数
return-----------r---------------------执行代码直到从当前函数返回
quit-------------q---------------------终止并退出
next-------------n---------------------执行下一行
print------------p---------------------打印变量的值
help-------------h---------------------帮助
args-------------a----------------------查看传入参数
-----------------回车--------------------重复上一条命令
break------------b----------------------显示所有断点
break lineno-----b lineno---------------在指定行设置断点
break file：lineno------b file：lineno--------在指定文件行设置断点
clear num--------------------------------删除指定断点
bt----------------------------------------查看函数调用栈

python -m pdb some.py



l：显示当前的代码
c:继续执行代码
n:执行下一行（函数当成一行）
b 行号：添加断点
b：查看断点
c 断点编号：删除断点
p：打印一个变量的值
a：打印所有变量的值
s：进入到函数里面

交互模式
进入python或ipython解释器
import pdb
pdb.run('testfun(args)')
pdb.set_trace()在程序里面埋藏断点，当程序运行到这行代码的时候就会进入pdb模式



多任务：
时间片轮转+优先级调度

并发：独立执行的组合，即单处理器的情况下，通过时间片的切换达到同时做多件事情的效果
并行：同时执行
并行是指同一时刻同时做多件事情，而并发是指同一时间间隔内做多件事情

python中完成多任务：
进程和程序的区别：
编写完没有运行的代码就叫程序。
正在运行的代码，就成为进程
进程是包含代码以外的运行环境等等的就是进程。
1.使用fork（）创建多进程：

原本程序运行的进程是主进程，而调用os.fork()之后会创建一个子进程
这时候相当于主进程和子进程都会调用一次os.fork()，但是主进程的返回值时>0的，而子进程是=0的
并且在两个进程中，都会调用fork（）方法后面的代码，这就是多任务程序
父进程跟子进程的调用顺序是不确定的，不同的操作系统的调度算法不同，执行顺序也可能不同
示例：
import os
import time
'''os.fork()创建一个子进程，相当于将当前代码复制一份
    os.fork()会有两个返回值，在父进程中返回的是1，子进程返回的是0
    这就是为什么下面程序的代码会交替打印------1----------和-------2----------的原因
'''
ret = os.fork()

if ret == 0:
    while True:
        print("------1-------")
        time.sleep(1)
else:
    while True:
        print("------2-------")
        time.sleep(1)
		
os.fork()会有两个返回值，在父进程中返回的是子进程的id，子进程则返回0

主进程结束，不会因为子进程没结束而不结束主进程

全局变量在多进程中不共享：全局变量，局部变量等等，都是每个子进程会有自己的一份，互不干扰
解决的方法：进程间通信

fork在window系统下无法使用

2.使用multiproccessing模块的Proccess类创建进程
Process创建子进程时，主进程会等子进程结束之后才会结束（跟fork不一样）

start：启动子进程
join（timeout）：timeout是等待结束的时间，如果超过这个时间还没结束，那么主进程就终止了。
terminate（）：不管任务是否完成，立即终止

3.使用进程池Pool创建进程
主进程一般用来等待，真正的任务都在子进程中执行

apply_async：非阻塞方式
apply:阻塞方式

from multiprocessing import Pool
import os
import random
import time

def worker(num):
    for i in range(5):
        print("======pid = %d=====num=%d"%(os.getpid(), num))
        time.sleep(1)

pool = Pool(3)

for i in range(10):
    print("-----%d----"%i)
    pool.apply_async(worker, (i,))#创建子进程来执行任务,第一个参数是任务函数，
                                    #第二个是任务函数的参数，需要用元组来保存

print("-----start-----")
pool.close()#关闭进程池，关闭后不再接受任何请求
#pool.join()#主进程 创建/添加 任务后，默认不会等待进程池中的任务执行完成后才结束
            #而是 当主进程的任务完成后 立马结束,如果没有join会导致进程池中的任务不会执行
print("----close----")


进程越多，当前系统的资源消耗越高，所以要控制好进程的数量



进程间通信Queue

put(xxx):想队列里面添加元素
qsize():队列中元素的个数
empty():是否为空
full():是否满了
get_nowait():不会等待添加
put_nowait():不会等待的添加

使用Process创建的多进程使用的队列是的multiprocessing下的Queue
使用进程池创建的多进程使用的队列是multiprocessing下Manager类下的Queue类
